<script>
    function getPullRequestDetails(pullLinks) {
        var pull_request_url = "";

    }
    (function(){
        // Create a closure and invoke it immediately to store token.
        var accessToken = '<%= session["github_access_token"] %>'
        $(document).ready(function () {
            $("#tmr tr ul").on("click", "li.tmr_tab", function (e, s) {
                pullLinks = $(e.delegateTarget).siblings(".tmr_tab_content").find("table.participants tr div#url a[href*='/pull/']");

                if(pullLinks.length) {
                    pull_request_url = $(pullLinks[0]).attr("href")
                }
                if(!pull_request_url) {
                    // Show that info in div
                    return;
                }
                var dataArray = pull_request_url.split('/');
                var pullRequestNumber = dataArray.pop();
                dataArray.pop();
                var repositoryName = dataArray.pop();
                var ownerName = dataArray.pop();

                $.ajax({
                    type: "POST",
                    url: "https://api.github.com/graphql",
                    headers: {
                        'Authorization': 'Bearer' + ' ' + accessToken
                    },
                    data: JSON.stringify({
                        query: `query {
                          repository(owner: ${ownerName}, name: ${repositoryName}) {
                            pullRequest(number: ${pullRequestNumber}) {
                              id
                              number
                              title
                              commits(first:10) {
                                edges {
                                  node {
                                    id
                                    commit{
                                      author{
                                        name
                                        email
                                        user {
                                          name
                                        }
                                      }
                                      additions
                                      deletions
                                      committedDate
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }`
                    }),
                    success: function (response) {
                        if(!response.data.repository.pullRequest.commits.edges.length) {
                            $(e.delegateTarget).siblings(".tmr_tab_content").find("div.github").html("");
                            return;
                        }
                        var userData = response.data.repository.pullRequest.commits.edges.reduce(function(accumulator, edge) {

                            var commit  = edge.node.commit;
                            var author = commit.author.name;
                            if (accumulator.hasOwnProperty(author)){
                                accumulator[author].additions += commit.additions;
                                accumulator[author].deletions += commit.deletions;
                                accumulator[author].totalCommits += 1;
                            }
                            else {
                                accumulator[author] = {
                                    additions: commit.additions,
                                    deletions: commit.deletions,
                                    totalCommits: 1,
                                    email: commit.author.email
                                }
                            }
                            return accumulator;
                        }, {});
                        var content = "<table id='myTable' class='table table-bordered tablesorter'><caption>GitHub Metrics</caption><colgroup><col><col class='c5'><col class='c1'><col class='c5'></colgroup><thead><th>Student</th><th>Lines of Code added</th><th>Lines of code deleted</th><th>Total Commits</th></thead><tbody>";
                        for(var author in userData) {
                            if (userData.hasOwnProperty(author)) {
                                var authorData = userData[author];
                                var name = (authorData.user && authorData.user.name) || `${author}(${authorData.email})`;
                                content += `<tr><td>${name}</td><td>${authorData.additions}</td><td>${authorData.deletions}</td><td>${authorData.totalCommits}</td></tr>`
                            }
                        }
                        content += "</tbody></table>"
                        $(e.delegateTarget).siblings(".tmr_tab_content").find("div.github").html(content);
                        $("#myTable").tablesorter().trigger("update");

                    },
                    error: function (httpObject, textStatus) {
                        switch(httpObject.status){
                            case 401:
                                // If token has expired, get a new one.
                                // status 401: unauthorized
                                //window.location.replace("https://github.com/login/oauth/authorize?client_id=9bc295b263c0386b247a");
                                $.ajax({
                                    type: "GET",
                                    url: "/grades/authorize_github"
                                });
                                break;
                            case 403:
                                // Forbidden. Most likely excedded rate limit or wrong creds.
                                $(e.delegateTarget).siblings(".tmr_tab_content").find("div.github").html("<p>GitHub rate limit exceeded.</p>");
                        }
                    }
                });
            });
        });
    })();
</script>
<h1>Summary report for <%= @assignment.name %></h1>`

<BR/>
<% if @scores[:teams] %>
  <a href="#" onClick="toggleAll(<%= @scores[:teams].length %>);return false;" id="teamAll" name="teamAll">Show all
    teams</a>
  <BR/><BR/>
<% end %>
<!-- If there are 1-member teams, the Teammate Review column should not appear in the score report.
If there is no metareviewing deadline, the “Reviewing” column should not appear in the score report.-->
<table id="tmr" class="table table-striped grades" width="100%">
  <!--ACS Render the appropriate partial for displaying the scores depending on the team size -->
  <% if @assignment.team_assignment? && @scores[:teams].length > 0 %>
    <%= render :partial => 'teams' %>
  <% else %>
    <tr>
      <td>No teams are defined for this assignment</td>
    </tr>
  <% end %>
</table>
<BR/><BR/>
<%= link_to 'Export ' + 'Grades',
            :controller => 'export_file',
            :action => 'start',
            :model => 'Assignment',
            :id => @assignment.id %> <BR/><BR/>
<a href="javascript:window.history.back()">Back</a>
